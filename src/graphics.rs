use std::{fs, io, process};
use std::io::Write;

use module::Module;
use pci::PciBus;
use sysfs_class::{PciDevice, SysClass};

use std::path::Path;

static MODPROBE_NVIDIA: &'static [u8] = br#"# Automatically generated by system76-power
"#;

static MODPROBE_INTEL: &'static [u8] = br#"# Automatically generated by system76-power
blacklist nouveau
blacklist nvidia
blacklist nvidia-drm
blacklist nvidia-modeset
alias nouveau off
alias nvidia off
alias nvidia-drm off
alias nvidia-modeset off
"#;

pub struct Graphics {
    pub bus: PciBus,
    pub intel: Vec<PciDevice>,
    pub nvidia: Vec<PciDevice>,
    pub nvidia_hda: Vec<PciDevice>,
    pub other: Vec<PciDevice>,
}

impl Graphics {
    pub fn new() -> io::Result<Graphics> {
        let bus = PciBus::new()?;

        info!("Rescanning PCI bus");
        bus.rescan()?;

        let mut intel = Vec::new();
        let mut nvidia = Vec::new();
        let mut nvidia_hda = Vec::new();
        let mut other = Vec::new();

        for dev in PciDevice::all()? {
            let c = dev.class()?;
            match (c >> 16) & 0xFF {
                0x03 => match dev.vendor()? {
                    0x10DE => {
                        info!("{}: NVIDIA graphics", dev.id());
                        nvidia.push(dev);
                    },
                    0x8086 => {
                        info!("{}: Intel graphics", dev.id());
                        intel.push(dev);
                    },
                    vendor => {
                        info!("{}: Other({:X}) graphics", dev.id(), vendor);
                        other.push(dev);
                    },
                },
                0x04 => match (c >> 8) & 0xff {
                    0x03 => match dev.vendor()? {
                        0x10DE => {
                            info!("{}: NVIDIA audio", dev.id());
                            nvidia_hda.push(dev);
                        },
                        _ => ()
                    },
                    _ => ()
                },
                _ => ()
            }
        }

        Ok(Graphics {
            bus,
            intel,
            nvidia,
            nvidia_hda,
            other,
        })
    }

    pub fn can_switch(&self) -> bool {
        !self.intel.is_empty() && !self.nvidia.is_empty()
    }

    pub fn get_vendor(&self) -> io::Result<String> {
        let modules = Module::all()?;
        let vendor = if modules.iter().any(|module| module.name == "nouveau" || module.name == "nvidia") {
            "nvidia".to_string()
        } else {
            "intel".to_string()
        };

        Ok(vendor)
    }

    pub fn set_vendor(&self, vendor: &str) -> io::Result<()> {
        if self.can_switch() {
            {
                let path = "/etc/modprobe.d/system76-power.conf";
                info!("Creating {}", path);
                let mut file = fs::OpenOptions::new()
                    .create(true)
                    .truncate(true)
                    .write(true)
                    .open(path)?;

                if vendor == "nvidia" {
                    file.write_all(MODPROBE_NVIDIA)?;
                } else {
                    file.write_all(MODPROBE_INTEL)?;
                }

                file.sync_all()?;
            }

            if vendor == "nvidia" {
                info!("Enabling nvidia-fallback.service");
                let status = process::Command::new("systemctl").arg("enable").arg("nvidia-fallback.service").status()?;
                if ! status.success() {
                    // Error is ignored in case this service is removed
                    error!("systemctl: failed with {}", status);
                }
            } else {
                info!("Disabling nvidia-fallback.service");
                let status = process::Command::new("systemctl").arg("disable").arg("nvidia-fallback.service").status()?;
                if ! status.success() {
                    // Error is ignored in case this service is removed
                    error!("systemctl: failed with {}", status);
                }
            }

            info!("Updating initramfs");            
            
            // Use Dracut or uprate-initramfs and return status

            let status;

            if process::Command::new("command").arg("-v").arg("dracut").status()?.success() {

                status = process::Command::new("dracut").arg("--force").status()?;

            } else if process::Command::new("command").arg("-v").arg("update-initramfs").status()?.success() {

                status = process::Command::new("update-initramfs").arg("-u").status()?;

            } else {
                // Tools not found. Raise an error.
                return Err(io::Error::new(
                    io::ErrorKind::Other,
                    format!("update-initramfs: failed. Nor Dracut nor update-initfamfs found.")
                ));
            }


            if ! status.success() {
                return Err(io::Error::new(
                    io::ErrorKind::Other,
                    format!("update-initramfs: failed with {}", status)
                ));
                }

            Ok(())
        } else {
            Err(io::Error::new(
                io::ErrorKind::Other,
                "does not have switchable graphics"
            ))
        }
    }

    pub fn get_power(&self) -> io::Result<bool> {
        if self.can_switch() {
            Ok(self.nvidia.iter().chain(self.nvidia_hda.iter()).any(|dev| dev.path().exists()))
        } else {
            Err(io::Error::new(
                io::ErrorKind::Other,
                "does not have switchable graphics"
            ))
        }
    }

    pub fn set_power(&self, power: bool) -> io::Result<()> {
        if self.can_switch() {
            if power {
                info!("Enabling graphics power");
                self.bus.rescan()?;
            } else {
                info!("Disabling graphics power");

                // Unbind NVIDIA audio devices
                for dev in self.nvidia_hda.iter() {
                    if dev.path().exists() {
                        match dev.driver() {
                            Ok(driver) => {
                                info!("{}: Unbinding {}", driver.id(), dev.id());
                                unsafe { driver.unbind(&dev) };
                            },
                            Err(err) => match err.kind() {
                                io::ErrorKind::NotFound => (),
                                _ => return Err(err),
                            }
                        }
                    }
                }

                // Remove NVIDIA graphics and audio devices
                for dev in self.nvidia.iter().chain(self.nvidia_hda.iter()) {
                    if dev.path().exists() {
                        match dev.driver() {
                            Ok(driver) => {
                                error!("{}: in use by {}", dev.id(), driver.id());
                                return Err(io::Error::new(
                                    io::ErrorKind::Other,
                                    "device in use"
                                ));
                            },
                            Err(err) => match err.kind() {
                                io::ErrorKind::NotFound => {
                                    info!("{}: Removing", dev.id());
                                    unsafe { dev.remove() }?;
                                },
                                _ => return Err(err),
                            }
                        }
                    } else {
                        warn!("{}: Already removed", dev.id());
                    }
                }
            }
            Ok(())
        } else {
            Err(io::Error::new(
                io::ErrorKind::Other,
                "does not have switchable graphics"
            ))
        }
    }

    pub fn auto_power(&self) -> io::Result<()> {
        self.set_power(self.get_vendor()? == "nvidia")
    }
}
